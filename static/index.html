<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Bot de Continuonus • Car Mode</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
      :root {
        --bg: #000;
        --panel: #0a0a0a;
        --edge: #2a0000;
        --accent: #ff0000;
        --accent-glow: #ff3333;
        --text: #ff6666;
        --text-bright: #ff9999;
        --scanner-red: #ff0000;
        --dashboard-bg: #0d0d0d;
      }
      
      * { margin: 0; padding: 0; box-sizing: border-box; }
      html, body, #root { height: 100%; overflow: hidden; }
      body { 
        background: var(--bg); 
        color: var(--text); 
        font-family: 'Share Tech Mono', monospace;
        user-select: none;
      }

      /* BOOT SEQUENCE */
      .boot-screen {
        position: fixed;
        inset: 0;
        background: #000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        opacity: 1;
        transition: opacity 0.5s;
      }
      .boot-screen.hidden { opacity: 0; pointer-events: none; }
      .boot-logo {
        font-family: 'Orbitron', sans-serif;
        font-size: 48px;
        font-weight: 700;
        color: var(--accent);
        text-shadow: 0 0 20px var(--accent), 0 0 40px var(--accent);
        letter-spacing: 4px;
        animation: pulse 2s ease-in-out infinite;
      }
      .boot-status {
        margin-top: 30px;
        font-size: 16px;
        color: var(--text-bright);
        font-family: 'Share Tech Mono', monospace;
      }
      .boot-progress {
        width: 300px;
        height: 4px;
        background: #222;
        margin-top: 20px;
        border-radius: 2px;
        overflow: hidden;
      }
      .boot-progress-bar {
        height: 100%;
        background: linear-gradient(90deg, var(--accent), var(--accent-glow));
        width: 0%;
        animation: loading 3s ease-out forwards;
        box-shadow: 0 0 10px var(--accent);
      }
      @keyframes loading {
        to { width: 100%; }
      }
      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
      }

      /* MAIN LAYOUT */
      .wrap { 
        height: 100%; 
        display: grid; 
        grid-template-rows: auto auto auto 1fr auto auto; 
        gap: 8px; 
        padding: 10px;
        background: radial-gradient(ellipse at 50% 0%, rgba(40,0,0,.3), #000 70%);
      }

      /* HEADER */
      .main-header {
        text-align: center;
        padding: 15px;
        background: linear-gradient(180deg, #1a0000 0%, #0a0a0a 100%);
        border: 2px solid var(--edge);
        border-radius: 12px;
        box-shadow: inset 0 0 20px rgba(0,0,0,0.8), 0 0 30px rgba(255,0,0,0.2);
      }
      .main-title {
        font-family: 'Orbitron', sans-serif;
        font-size: 32px;
        font-weight: 700;
        color: var(--accent);
        text-shadow: 0 0 20px var(--accent), 0 0 40px var(--accent);
        letter-spacing: 4px;
        margin: 0;
      }

      /* ANIMATED SCANNER BAR */
      .scanner-bar {
        height: 40px;
        background: #0a0a0a;
        border: 2px solid var(--edge);
        border-radius: 8px;
        position: relative;
        overflow: hidden;
        box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
      }
      .scanner-lights {
        display: flex;
        gap: 4px;
        padding: 8px;
        height: 100%;
        align-items: center;
        justify-content: center;
      }
      .scanner-led {
        width: 8px;
        height: 24px;
        background: #1a0000;
        border-radius: 2px;
        transition: all 0.1s;
      }
      .scanner-sweep {
        position: absolute;
        top: 0;
        left: -100px;
        width: 100px;
        height: 100%;
        background: linear-gradient(90deg, 
          transparent, 
          rgba(255,0,0,0.3), 
          var(--accent), 
          rgba(255,0,0,0.3), 
          transparent
        );
        animation: sweep 2s ease-in-out infinite;
        filter: blur(8px);
      }
      .scanner-sweep.active {
        animation: sweep 1s ease-in-out infinite;
      }
      @keyframes sweep {
        0% { left: -100px; }
        100% { left: 100%; }
      }

      /* DASHBOARD STATS */
      .dashboard {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 8px;
      }
      .stat-box {
        background: linear-gradient(180deg, #120000 0%, #080000 100%);
        border: 2px solid var(--edge);
        border-radius: 8px;
        padding: 10px;
        box-shadow: inset 0 0 15px #000;
        text-align: center;
      }
      .stat-label {
        font-family: 'Orbitron', sans-serif;
        font-size: 10px;
        color: var(--text);
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 5px;
      }
      .stat-value {
        font-family: 'Orbitron', sans-serif;
        font-size: 20px;
        font-weight: 700;
        color: var(--accent-glow);
        text-shadow: 0 0 10px var(--accent);
      }

      /* VOICE WAVEFORM */
      .waveform-container {
        height: 60px;
        background: #0a0a0a;
        border: 2px solid var(--edge);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 3px;
        padding: 10px;
        box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
      }
      .waveform-bar {
        width: 4px;
        height: 8px;
        background: #2a0000;
        border-radius: 2px;
        transition: all 0.1s;
      }
      .waveform-bar.active {
        background: var(--accent);
        box-shadow: 0 0 8px var(--accent);
        animation: wave 0.5s ease-in-out infinite alternate;
      }
      @keyframes wave {
        from { height: 8px; }
        to { height: 40px; }
      }

      /* CHAT PANEL */
      .panel {
        background: var(--dashboard-bg);
        border: 2px solid var(--edge);
        border-radius: 12px;
        box-shadow: inset 0 0 30px #000;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        overflow: hidden;
      }
      .panel-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-family: 'Orbitron', sans-serif;
        font-size: 12px;
        color: var(--text-bright);
        padding: 8px;
        background: #0a0a0a;
        border: 1px solid var(--edge);
        border-radius: 6px;
      }

      /* CHAT MESSAGES */
      .chat {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        padding: 10px;
        font-size: 18px;
        line-height: 1.5;
        background: radial-gradient(ellipse at 50% 0%, rgba(40,0,0,.2), transparent 60%);
        border-radius: 8px;
      }
      .msg {
        margin: 12px 0;
        animation: slideIn 0.3s ease-out;
      }
      @keyframes slideIn {
        from { opacity: 0; transform: translateX(-20px); }
        to { opacity: 1; transform: translateX(0); }
      }
      .loading-dots {
        display: inline-block;
        animation: blink 1.4s infinite;
      }
      .loading-dots::after {
        content: '...';
        animation: dots 1.4s infinite;
      }
      @keyframes dots {
        0%, 20% { content: '.'; }
        40% { content: '..'; }
        60%, 100% { content: '...'; }
      }
      @keyframes blink {
        0%, 50%, 100% { opacity: 1; }
        25%, 75% { opacity: 0.3; }
      }
      .meta {
        font-family: 'Orbitron', sans-serif;
        font-size: 11px;
        color: var(--text);
        margin-bottom: 4px;
        letter-spacing: 2px;
      }
      .user { color: #ff9999; }
      .bot { 
        color: var(--accent-glow);
        text-shadow: 0 0 5px rgba(255,0,0,0.3);
      }
      .intro {
        color: var(--text);
        text-align: center;
        font-style: italic;
        opacity: 0.7;
      }

      /* CONTROL BUTTONS */
      .controls {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 8px;
      }
      .control-btn {
        background: linear-gradient(180deg, #2a0000 0%, #150000 100%);
        border: 3px solid var(--edge);
        border-radius: 12px;
        padding: 18px;
        font-family: 'Orbitron', sans-serif;
        font-size: 16px;
        font-weight: 700;
        color: var(--text-bright);
        cursor: pointer;
        transition: all 0.2s;
        text-transform: uppercase;
        letter-spacing: 2px;
        box-shadow: 0 0 15px rgba(0,0,0,0.5), inset 0 0 10px rgba(0,0,0,0.3);
        position: relative;
        overflow: hidden;
      }
      .control-btn:before {
        content: '';
        position: absolute;
        inset: 0;
        background: linear-gradient(180deg, rgba(255,255,255,0.1), transparent);
        opacity: 0;
        transition: opacity 0.2s;
      }
      .control-btn:hover:before { opacity: 1; }
      .control-btn:active {
        transform: scale(0.98);
        box-shadow: 0 0 20px var(--accent), inset 0 0 15px rgba(255,0,0,0.3);
      }
      .control-btn.active {
        background: linear-gradient(180deg, #550000 0%, #2a0000 100%);
        border-color: var(--accent);
        box-shadow: 0 0 25px var(--accent), inset 0 0 20px rgba(255,0,0,0.4);
        animation: btnPulse 1s ease-in-out infinite;
      }
      @keyframes btnPulse {
        0%, 100% { box-shadow: 0 0 25px var(--accent), inset 0 0 20px rgba(255,0,0,0.4); }
        50% { box-shadow: 0 0 35px var(--accent), inset 0 0 25px rgba(255,0,0,0.6); }
      }
      .control-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      /* INPUT AREA */
      .input-area {
        display: grid;
        grid-template-columns: 1fr auto auto;
        gap: 8px;
      }
      .start-btn {
        grid-column: 1 / -1;
        font-size: 32px !important;
        padding: 30px !important;
        font-weight: 700;
        letter-spacing: 4px;
      }
      input {
        background: #0a0a0a;
        border: 3px solid var(--edge);
        border-radius: 10px;
        padding: 16px;
        color: var(--text-bright);
        font-size: 18px;
        font-family: 'Share Tech Mono', monospace;
        outline: none;
        box-shadow: inset 0 0 15px rgba(0,0,0,0.8);
      }
      input::placeholder { color: #663333; }
      input:focus {
        border-color: var(--accent);
        box-shadow: inset 0 0 15px rgba(0,0,0,0.8), 0 0 15px rgba(255,0,0,0.3);
      }

      /* SCROLLBAR */
      .chat::-webkit-scrollbar { width: 8px; }
      .chat::-webkit-scrollbar-track { background: #0a0a0a; border-radius: 4px; }
      .chat::-webkit-scrollbar-thumb { background: #4a0000; border-radius: 4px; }
      .chat::-webkit-scrollbar-thumb:hover { background: #6a0000; }

      /* RESPONSIVE */
      @media (max-width: 768px) {
        .dashboard { grid-template-columns: repeat(2, 1fr); }
        .controls { grid-template-columns: 1fr 1fr; }
        .input-area { grid-template-columns: 1fr auto; }
        .boot-logo { font-size: 32px; }
        .stat-value { font-size: 16px; }
        .main-title { font-size: 24px; }
      }

      /* LANGUAGE SELECTOR */
      .language-selector {
        position: fixed;
        inset: 0;
        background: #000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        gap: 40px;
      }
      .language-selector.hidden { display: none; }
      .language-title {
        font-family: 'Orbitron', sans-serif;
        font-size: 36px;
        font-weight: 700;
        color: var(--accent);
        text-shadow: 0 0 20px var(--accent), 0 0 40px var(--accent);
        letter-spacing: 4px;
        margin-bottom: 20px;
      }
      .language-buttons {
        display: flex;
        gap: 30px;
      }
      .language-btn {
        font-family: 'Orbitron', sans-serif;
        font-size: 32px;
        font-weight: 700;
        padding: 40px 80px;
        background: linear-gradient(180deg, #1a0000 0%, #0a0a0a 100%);
        border: 3px solid var(--edge);
        border-radius: 12px;
        color: var(--accent-glow);
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 0 30px rgba(255,0,0,0.2), inset 0 0 20px rgba(0,0,0,0.8);
        text-shadow: 0 0 10px var(--accent);
      }
      .language-btn:hover {
        background: linear-gradient(180deg, #2a0000 0%, #1a0a0a 100%);
        border-color: var(--accent);
        box-shadow: 0 0 50px rgba(255,0,0,0.5), inset 0 0 30px rgba(0,0,0,0.8);
        transform: scale(1.05);
      }
      .language-btn:active {
        transform: scale(0.98);
      }

      /* LANDSCAPE MODE (for car tablets) */
      @media (orientation: landscape) and (max-height: 600px) {
        .wrap { grid-template-rows: auto auto auto 1fr auto; gap: 6px; padding: 8px; }
        .scanner-bar { height: 30px; }
        .waveform-container { height: 40px; }
        .control-btn { padding: 12px; font-size: 14px; }
        .chat { font-size: 16px; }
        .main-title { font-size: 20px; }
        .main-header { padding: 10px; }
        .language-title { font-size: 24px; }
        .language-btn { font-size: 20px; padding: 25px 50px; }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <!-- React via CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <script>
      const { useState, useRef, useEffect } = React;

      function BootScreen({ onComplete, language }) {
        const steps = language === 'en' ? [
          { msg: 'INITIALIZING SYSTEMS...', delay: 500 },
          { msg: 'LOADING NEURAL NETWORK...', delay: 800 },
          { msg: 'CONNECTING TO MEMORY BANKS...', delay: 1200 },
          { msg: 'CALIBRATING VOICE SYNTHESIS...', delay: 1800 },
          { msg: 'SYSTEM READY', delay: 2800 },
        ] : [
          { msg: 'INITIALISERER SYSTEMER...', delay: 500 },
          { msg: 'INDLÆSER NEURALT NETVÆRK...', delay: 800 },
          { msg: 'FORBINDER TIL HUKOMMELSESBANKER...', delay: 1200 },
          { msg: 'KALIBRERER STEMMESYNTESE...', delay: 1800 },
          { msg: 'SYSTEM KLAR', delay: 2800 },
        ];
        
        const [status, setStatus] = useState(steps[0].msg);
        
        useEffect(() => {
          steps.forEach(({ msg, delay }) => {
            setTimeout(() => setStatus(msg), delay);
          });
          
          setTimeout(() => onComplete(), 3200);
        }, []);
        
        return React.createElement('div', { className: 'boot-screen' },
          React.createElement('div', { className: 'boot-logo' }, 'BOT DE CONTINUONUS'),
          React.createElement('div', { className: 'boot-status' }, status),
          React.createElement('div', { className: 'boot-progress' },
            React.createElement('div', { className: 'boot-progress-bar' })
          )
        );
      }

      function LanguageSelector({ onSelect }) {
        return React.createElement('div', { className: 'language-selector' },
          React.createElement('div', { className: 'language-title' }, 'VÆLG SPROG / SELECT LANGUAGE'),
          React.createElement('div', { className: 'language-buttons' },
            React.createElement('button', {
              className: 'language-btn',
              onClick: () => onSelect('da')
            }, 'DANSK'),
            React.createElement('button', {
              className: 'language-btn',
              onClick: () => onSelect('en')
            }, 'ENGLISH')
          )
        );
      }

      function ScannerBar({ active }) {
        return React.createElement('div', { className: 'scanner-bar' },
          React.createElement('div', { className: 'scanner-lights' },
            [...Array(20)].map((_, i) => 
              React.createElement('div', { key: i, className: 'scanner-led' })
            )
          ),
          React.createElement('div', { className: 'scanner-sweep' + (active ? ' active' : '') })
        );
      }

      function Dashboard({ msgCount, audioPlaying, queueLength, responseTime }) {
        return React.createElement('div', { className: 'dashboard' },
          React.createElement('div', { className: 'stat-box' },
            React.createElement('div', { className: 'stat-label' }, 'BESKEDER'),
            React.createElement('div', { className: 'stat-value' }, msgCount)
          ),
          React.createElement('div', { className: 'stat-box' },
            React.createElement('div', { className: 'stat-label' }, 'LYDSTATUS'),
            React.createElement('div', { className: 'stat-value' }, audioPlaying ? 'AKTIV' : 'INAKTIV')
          ),
          React.createElement('div', { className: 'stat-box' },
            React.createElement('div', { className: 'stat-label' }, 'KØ'),
            React.createElement('div', { className: 'stat-value' }, queueLength)
          ),
          React.createElement('div', { className: 'stat-box' },
            React.createElement('div', { className: 'stat-label' }, 'SVARTID'),
            React.createElement('div', { className: 'stat-value' }, responseTime + 's')
          )
        );
      }

      function Waveform({ active }) {
        return React.createElement('div', { className: 'waveform-container' },
          [...Array(30)].map((_, i) => 
            React.createElement('div', { 
              key: i, 
              className: 'waveform-bar' + (active && Math.random() > 0.3 ? ' active' : ''),
              style: active ? { animationDelay: (i * 0.05) + 's' } : {}
            })
          )
        );
      }

      function App() {
        const [languageSelected, setLanguageSelected] = useState(false);
        const [language, setLanguage] = useState('da');
        const [stage, setStage] = useState('START'); // START, WELCOME, MEMORY_1, MEMORY_2, QUESTION_1, QUESTION_2, GOODBYE
        const [booting, setBooting] = useState(true);
        const [msgs, setMsgs] = useState([]);
        const [input, setInput] = useState('');
        const [loading, setLoading] = useState(false);
        const [loadingStage, setLoadingStage] = useState(0);
        const [sessionId] = useState(() => 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
        const [audioPlaying, setAudioPlaying] = useState(false);
        const [audioReady, setAudioReady] = useState(false);
        const [audioQueue, setAudioQueue] = useState([]);
        const [responseTime, setResponseTime] = useState(0);
        const [isListening, setIsListening] = useState(false);
        const [musicPlaying, setMusicPlaying] = useState(false);
        const chatRef = useRef(null);
        const audioEl = useRef(null);
        const musicEl = useRef(null);
        const recognitionRef = useRef(null);
        const loadingIntervalRef = useRef(null);

        // Scripted messages for guided experience
        const scripts = {
          da: {
            WELCOME: "Hej, sikke en lang mærkelig tur vi har været på, men der er stadig en lang vej forude. Velkommen til vores køretøj. Vi er Bot de ContinuOnus, en AI-genereret chatbot, der taler med kunstneren Helene Nymanns klonede stemme.\n\nVi har måske hendes stemme, men vi taler gennem et datasæt eller rettere gennem oplevelserne fra tusindvis af mennesker, der var her før dig. De har alle sammen delt, hvad de husker, som de vil have fremtiden til at huske. De har placeret denne erindring på en hjemmeside kendt som continuonus. På hjemmesiden dyrkes et kort kendt som Carte de Continuonus.\n\nLad os nu rejse gennem det kort. Her kan du dele noget, du føler er vigtigt for fremtiden at huske, og du kan spørge os om, hvad tidligere besøgende delte.",
            MEMORY_1: "Del venligst en erindring? Noget du gerne vil have, at folk i fremtiden husker at huske. Tryk på Del-knappen, når du er færdig.",
            MEMORY_2: "Vil du tilføje noget mere? Tryk på Del-knappen, når du er færdig.",
            QUESTION_1: "Vil du nu spørge os om, hvad andre har følt var vigtigt for fremtiden at huske at huske? Du er i deres fremtid. Du kan spørge om følelser eller emner eller noget, du har spekuleret over. Tryk på Del-knappen, når du er færdig.",
            QUESTION_2: "Vil du spørge om noget andet? Tryk på Del-knappen, når du er færdig.",
            GOODBYE: "Tak fordi du tog denne del af rejsen med os. Du er også en del af det kontinuerlige landskab nu."
          },
          en: {
            WELCOME: "Hello, what a long strange trip we've been on, but there's still a long road ahead. Welcome to our vehicle. We are Bot de ContinuOnus, an AI generated chatbot speaking in the cloned voice of the artist Helene Nymann.\n\nWe may have her voice, but we're speaking through a data set or rather through the experiences of thousands of people who were here before you. All of whom have shared what they remember that they want the future to remember. They have placed that memory onto a website known as continuonus. On the website a map known as Carte de Continuonus is being cultivated.\n\nNow let's journey through that map. In here you may share something that you feel is important for the future to remember and you can ask us about what previous visitors shared.",
            MEMORY_1: "Please share a memory? Something you'd like those people in the future to remember to remember. Press the Share button when you're done.",
            MEMORY_2: "Would you like to add anything else? Press the Share button when you're done.",
            QUESTION_1: "Now would you ask us about what others have felt it was important for the future to remember to remember? You are in their future. You can ask about emotions, or topics, or something you've been wondering about. Press the Share button when you're done.",
            QUESTION_2: "Would you like to ask something else? Press the Share button when you're done.",
            GOODBYE: "Thank you for taking this part of the journey with us. You too are part of the continuOnus landscape now."
          }
        };

        useEffect(() => {
          if (chatRef.current) chatRef.current.scrollTop = chatRef.current.scrollHeight;
        }, [msgs, loading]);

        // Monitor audio element and its state
        useEffect(() => {
          console.log('[AUDIO] Component mounted');
          const checkAudio = () => {
            if (audioEl.current) {
              console.log('[AUDIO] Audio element is available');
              console.log('[AUDIO] Audio element ID:', audioEl.current.id);
              console.log('[AUDIO] Current src:', audioEl.current.src ? 'loaded' : 'empty');
              console.log('[AUDIO] Paused:', audioEl.current.paused);
              console.log('[AUDIO] ReadyState:', audioEl.current.readyState);
            } else {
              console.error('[AUDIO] Audio element ref is NULL!');
            }
          };
          
          // Check immediately
          checkAudio();
          
          // Check again after render completes
          setTimeout(checkAudio, 50);
          setTimeout(checkAudio, 200);
        }, []);

        useEffect(() => {
          if (loading) {
            setLoadingStage(0);
            loadingIntervalRef.current = setInterval(() => {
              setLoadingStage(s => (s + 1) % 5);
            }, 1500);
          } else {
            if (loadingIntervalRef.current) {
              clearInterval(loadingIntervalRef.current);
              loadingIntervalRef.current = null;
            }
          }
          return () => {
            if (loadingIntervalRef.current) {
              clearInterval(loadingIntervalRef.current);
            }
          };
        }, [loading]);

        // Set up audio event listeners AFTER boot screen completes
        useEffect(() => {
          // Don't set up listeners during boot - audio element doesn't exist yet!
          if (booting) {
            console.log('[AUDIO] Still booting, skipping listener setup');
            return;
          }
          
          console.log('[AUDIO] Boot complete, setting up audio listeners');
          
          // Wait for next tick to ensure element is rendered
          const timer = setTimeout(() => {
            const el = audioEl.current;
            if (!el) {
              console.error('[AUDIO] CRITICAL: Audio element still not available after boot!');
              return;
            }
            
            console.log('[AUDIO] Setting up event listeners on element:', el.id);
            
            const onPlay = () => {
              console.log('[AUDIO] EVENT: Playing');
              setAudioPlaying(true);
              setAudioReady(true);
            };
            const onPause = () => {
              console.log('[AUDIO] EVENT: Paused');
              setAudioPlaying(false);
            };
            const onEnded = () => {
              console.log('[AUDIO] EVENT: Ended');
              setAudioPlaying(false);
              // Check queue in the function, don't depend on it in useEffect
              setTimeout(() => {
                if (audioQueue.length > 0) {
                  const next = audioQueue[0];
                  setAudioQueue(q => q.slice(1));
                  console.log('[AUDIO] Loading next from queue');
                  el.src = 'data:audio/mpeg;base64,' + next;
                  el.play().catch((err) => console.error('[AUDIO] Auto-play next failed:', err));
                }
              }, 100);
            };
            const onCanPlay = () => {
              console.log('[AUDIO] EVENT: Can play - audio ready');
              setAudioReady(true);
            };
            const onError = (e) => {
              console.error('[AUDIO] EVENT: Error loading audio', e);
              setAudioReady(false);
            };
            
            el.addEventListener('play', onPlay);
            el.addEventListener('pause', onPause);
            el.addEventListener('ended', onEnded);
            el.addEventListener('canplay', onCanPlay);
            el.addEventListener('error', onError);
            
            console.log('[AUDIO] Event listeners attached successfully');
          }, 100); // Slightly longer delay to ensure render completes
          
          return () => clearTimeout(timer);
        }, [booting]); // Depend on booting - set up listeners when it becomes false

        const playVoice = (b64) => {
          const el = audioEl.current;
          if (!el) {
            console.error('[AUDIO] playVoice: No audio element!');
            return;
          }
          
          console.log('[AUDIO] playVoice called, currently playing:', audioPlaying);
          
          if (audioPlaying) {
            // If already playing, add to queue
            setAudioQueue(q => [...q, b64]);
            console.log('[AUDIO] Added to queue, new queue length:', audioQueue.length + 1);
          } else {
            // Load the audio - don't set audioReady here, let canplay event handle it
            console.log('[AUDIO] Loading new audio source');
            el.src = 'data:audio/mpeg;base64,' + b64;
            console.log('[AUDIO] Source set, attempting autoplay');
            // Auto-play the first audio
            el.play().then(() => {
              console.log('[AUDIO] Autoplay SUCCESS');
            }).catch((err) => {
              console.error('[AUDIO] Autoplay FAILED:', err);
              console.log('[AUDIO] User must click AFSPIL button');
              // audioReady will be set by canplay event
            });
          }
        };

        const togglePlayPause = () => {
          const el = audioEl.current;
          console.log('[AUDIO] togglePlayPause clicked');
          console.log('[AUDIO] - Element exists:', !!el);
          console.log('[AUDIO] - Has src:', !!el?.src);
          console.log('[AUDIO] - audioReady:', audioReady);
          console.log('[AUDIO] - audioPlaying:', audioPlaying);
          
          if (!el || !el.src) {
            console.error('[AUDIO] Cannot play: No audio loaded');
            return;
          }
          
          if (audioPlaying) {
            console.log('[AUDIO] Pausing...');
            el.pause();
          } else {
            console.log('[AUDIO] Playing...');
            el.play().then(() => {
              console.log('[AUDIO] Play SUCCESS');
            }).catch((err) => {
              console.error('[AUDIO] Play FAILED:', err);
            });
          }
        };

        const skipAudio = () => {
          const el = audioEl.current;
          if (!el) return;
          
          console.log('[AUDIO] Skipping, queue length:', audioQueue.length);
          
          el.pause();
          el.currentTime = 0;
          
          if (audioQueue.length > 0) {
            const next = audioQueue[0];
            setAudioQueue(q => q.slice(1));
            el.src = 'data:audio/mpeg;base64,' + next;
            setAudioReady(true);
            el.play().catch((err) => console.error('[AUDIO] Skip play failed:', err));
          } else {
            setAudioPlaying(false);
            setAudioReady(false);
          }
        };

        const send = async (e) => {
          e.preventDefault();
          
          // Handle special stages
          if (stage === 'START') {
            handleStart();
            return;
          }
          
          if (stage === 'WELCOME') {
            advanceStage(); // Move to MEMORY_1
            return;
          }
          
          if (stage === 'GOODBYE') {
            // End experience and reset to language selection
            console.log('[GOODBYE] User clicked finish, resetting experience');
            resetExperience();
            return;
          }
          
          const text = input.trim();
          if (!text || loading) return;
          
          console.log('[FRONTEND] Sending:', text, 'Stage:', stage, 'Mode:', getStageMode());
          setInput('');
          setMsgs(m => [...m, { role: 'user', text }]);
          setLoading(true);

          try {
            const form = new URLSearchParams();
            form.set('user_input', text);
            form.set('session_id', sessionId);
            form.set('user_name', 'Museumsdeltagere');
            form.set('user_location', 'Bilen');
            form.set('language', language);
            form.set('mode', getStageMode());
            form.set('continuous_json', JSON.stringify({ keystrokes: text.length, ts: Date.now(), stage: stage }));

            const startTime = Date.now();
            const res = await fetch('/api/chat', {
              method: 'POST',
              headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
              body: form.toString()
            });

            const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
            setResponseTime(elapsed);

            if (!res.ok) throw new Error(`HTTP ${res.status}`);

            const data = await res.json();
            const botText = data.text || '(no response)';
            
            // Only show bot response for QUESTION stages, not MEMORY stages
            if (getStageMode() === 'question') {
              setMsgs(m => [...m, { role: 'bot', text: botText }]);
              
              if (data.audio_b64) {
                playVoice(data.audio_b64);
                
                // Wait for ALL audio (including queue) to finish before advancing
                const el = audioEl.current;
                if (el) {
                  const checkAndAdvance = () => {
                    // Check if queue is empty and audio has ended
                    if (audioQueue.length === 0 && el.paused) {
                      console.log('[STAGE] All audio finished, advancing stage in 2 seconds');
                      el.removeEventListener('ended', checkAndAdvance);
                      setTimeout(() => advanceStage(), 2000); // 2 second pause after audio ends
                    } else {
                      console.log('[STAGE] Still audio in queue or playing, waiting...');
                    }
                  };
                  el.addEventListener('ended', checkAndAdvance);
                } else {
                  // Fallback if no audio element
                  setTimeout(() => advanceStage(), 5000);
                }
              } else {
                // No audio, advance after short delay
                setTimeout(() => advanceStage(), 3000);
              }
            } else {
              // Memory mode - advance quickly after saving
              setTimeout(() => advanceStage(), 1500);
            }
            
          } catch (error) {
            console.error('[FRONTEND] ERROR:', error);
            setMsgs(m => [...m, { role: 'bot', text: `Error: ${error.message}` }]);
          } finally {
            setLoading(false);
          }
        };

        const startVoice = () => {
          const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
          if (!SR) {
            alert(language === 'en' ? 'Speech recognition not supported' : 'Stemmegenkendelse understøttes ikke');
            return;
          }
          
          if (isListening && recognitionRef.current) {
            recognitionRef.current.stop();
            setIsListening(false);
            return;
          }
          
          const recog = new SR();
          recog.lang = language === 'en' ? 'en-US' : 'da-DK';
          recog.continuous = false;
          recog.interimResults = false;
          
          recog.onstart = () => setIsListening(true);
          recog.onend = () => setIsListening(false);
          recog.onresult = (e) => {
            const transcript = e.results[0][0].transcript;
            setInput(transcript);
            setIsListening(false);
          };
          recog.onerror = () => setIsListening(false);
          
          recog.start();
          recognitionRef.current = recog;
        };

        const handleLanguageSelect = (lang) => {
          setLanguage(lang);
          setLanguageSelected(true);
        };

        // Reset the entire experience back to language selection
        const resetExperience = () => {
          console.log('[RESET] Resetting experience to language selection');
          
          // Stop any playing audio
          const el = audioEl.current;
          if (el) {
            el.pause();
            el.currentTime = 0;
            el.src = '';
          }
          
          // Clear audio queue
          setAudioQueue([]);
          
          // Reset all state
          setLanguageSelected(false);
          setBooting(false);
          setStage('START');
          setMsgs([]);
          setInput('');
          setLoading(false);
          setAudioPlaying(false);
          setAudioReady(false);
          setIsListening(false);
          
          // Generate new session ID for next experience
          setSessionId('session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
          
          console.log('[RESET] Ready for new experience');
        };

        // Function to play pre-recorded scripted audio
        const playScriptedAudio = (stageName) => {
          console.log('[AUDIO] Playing pre-recorded audio for stage:', stageName);
          const el = audioEl.current;
          if (!el) {
            console.error('[AUDIO] Audio element not available');
            return;
          }
          
          // Use pre-recorded audio files (generated by generate_scripted_audio.py)
          const audioFile = `/static/audio/${language}_${stageName}.mp3`;
          console.log('[AUDIO] Loading:', audioFile);
          
          el.src = audioFile;
          setAudioReady(true);
          
          // Auto-play the scripted audio
          el.play().then(() => {
            console.log('[AUDIO] Pre-recorded audio playing');
          }).catch((err) => {
            console.error('[AUDIO] Failed to play pre-recorded audio:', err);
            console.log('[AUDIO] User must click AFSPIL button');
          });
        };

        const handleStart = () => {
          // Play startup music (placeholder - user needs to add music file)
          // playMusic('startup');
          setStage('WELCOME');
          
          // Auto-speak welcome message with pre-recorded audio
          setTimeout(() => {
            const welcomeMsg = scripts[language].WELCOME;
            setMsgs([{ role: 'bot', text: welcomeMsg }]);
            // Play pre-recorded audio immediately
            playScriptedAudio('WELCOME');
          }, 500);
        };

        const advanceStage = () => {
          const stageOrder = ['START', 'WELCOME', 'MEMORY_1', 'MEMORY_2', 'QUESTION_1', 'QUESTION_2', 'GOODBYE'];
          const currentIndex = stageOrder.indexOf(stage);
          const nextStage = stageOrder[currentIndex + 1];
          
          if (nextStage) {
            setStage(nextStage);
            
            // Play transition music between stages (placeholder)
            // playMusic('transition');
            
            // Auto-show next scripted message with pre-recorded audio
            if (scripts[language][nextStage]) {
              setTimeout(() => {
                const stageMsg = scripts[language][nextStage];
                setMsgs(m => [...m, { role: 'bot', text: stageMsg }]);
                // Play pre-recorded audio immediately
                playScriptedAudio(nextStage);
              }, 500);
            }
            
            // If GOODBYE, wait for audio to finish then auto-reset after delay
            if (nextStage === 'GOODBYE') {
              const el = audioEl.current;
              if (el) {
                const autoResetAfterGoodbye = () => {
                  console.log('[GOODBYE] Audio finished, will auto-reset in 5 seconds');
                  el.removeEventListener('ended', autoResetAfterGoodbye);
                  // playMusic('ending');
                  // Auto-reset after 5 seconds (user can also click button to reset immediately)
                  setTimeout(() => {
                    console.log('[GOODBYE] Auto-resetting experience');
                    resetExperience();
                  }, 5000);
                };
                el.addEventListener('ended', autoResetAfterGoodbye);
              }
            }
          }
        };

        const getStageMode = () => {
          // MEMORY stages save without AI response, QUESTION stages run full pipeline
          return (stage === 'MEMORY_1' || stage === 'MEMORY_2') ? 'memory' : 'question';
        };

        const getPlaceholder = () => {
          if (language === 'en') {
            if (stage === 'MEMORY_1' || stage === 'MEMORY_2') return 'Share a memory...';
            if (stage === 'QUESTION_1' || stage === 'QUESTION_2') return 'Ask a question...';
            return 'Type your message...';
          } else {
            if (stage === 'MEMORY_1' || stage === 'MEMORY_2') return 'Del en erindring...';
            if (stage === 'QUESTION_1' || stage === 'QUESTION_2') return 'Stil et spørgsmål...';
            return 'Skriv din besked...';
          }
        };

        const getButtonText = () => {
          if (stage === 'START') return language === 'en' ? 'START' : 'START';
          if (stage === 'WELCOME') return language === 'en' ? 'CONTINUE' : 'FORTSÆT';
          if (stage === 'GOODBYE') return language === 'en' ? 'FINISH' : 'AFSLUT';
          return language === 'en' ? 'SHARE' : 'DEL';
        };

        if (!languageSelected) {
          return React.createElement(LanguageSelector, { onSelect: handleLanguageSelect });
        }

        if (booting) {
          return React.createElement(BootScreen, { 
            onComplete: () => setBooting(false),
            language: language
          });
        }

        return React.createElement('div', { className: 'wrap' },
          React.createElement('div', { className: 'main-header' },
            React.createElement('h1', { className: 'main-title' }, 'BOT DE CONTINUONUS')
          ),
          React.createElement(ScannerBar, { active: loading || audioPlaying }),
          React.createElement(Dashboard, { 
            msgCount: msgs.length, 
            audioPlaying: audioPlaying,
            queueLength: audioQueue.length,
            responseTime: responseTime
          }),
          React.createElement('div', { className: 'panel' },
            React.createElement('div', { className: 'panel-head' },
              React.createElement('span', null, `◉ ${stage === 'START' ? (language === 'en' ? 'READY TO BEGIN' : 'KLAR TIL START') : stage === 'MEMORY_1' || stage === 'MEMORY_2' ? (language === 'en' ? 'MEMORY SHARING' : 'ERINDRINGSDELING') : stage === 'QUESTION_1' || stage === 'QUESTION_2' ? (language === 'en' ? 'ASKING QUESTIONS' : 'STILLER SPØRGSMÅL') : stage === 'GOODBYE' ? (language === 'en' ? 'JOURNEY COMPLETE' : 'REJSE AFSLUTTET') : (language === 'en' ? 'WELCOME' : 'VELKOMMEN')}`),
              React.createElement('span', null, loading ? (language === 'en' ? 'PROCESSING...' : 'BEHANDLER...') : (language === 'en' ? 'READY' : 'KLAR'))
            ),
            React.createElement('div', { className: 'chat', ref: chatRef },
              msgs.length === 0 && stage === 'START' && React.createElement('div', { className: 'intro' }, 
                language === 'en' 
                  ? 'A Long Road Ahead (Ringsted Rider)\n\nBot de ContinuOnus (2025)\n\nPress START to begin the journey...'
                  : 'En Lang Vej Foran Os (Ringsted Rider)\n\nBot de ContinuOnus (2025)\n\nTryk START for at begynde rejsen...'
              ),
              msgs.map((m, i) => React.createElement('div', { key: i, className: 'msg' },
                React.createElement('div', { className: 'meta ' + m.role }, 
                  m.role === 'user' 
                    ? (language === 'en' ? '→ YOU' : '→ DIG')
                    : '← BOT'
                ),
                React.createElement('div', null, m.text)
              )),
              loading && React.createElement('div', { className: 'msg bot' },
                React.createElement('div', { className: 'meta bot' }, '← BOT'),
                React.createElement('div', null, 
                  React.createElement('span', { className: 'loading-dots' }, 
                    language === 'en' ? (
                      loadingStage === 0 ? 'Fetching source data' :
                      loadingStage === 1 ? 'Analyzing collective wishes' :
                      loadingStage === 2 ? 'Searching conversation history' :
                      loadingStage === 3 ? 'Connecting echoes from the past' :
                      'Generating clairvoyant message'
                    ) : (
                      loadingStage === 0 ? 'Henter kildedata' :
                      loadingStage === 1 ? 'Analyserer kollektive ønsker' :
                      loadingStage === 2 ? 'Søger i samtalehistorik' :
                      loadingStage === 3 ? 'Forbinder ekkoer fra fortiden' :
                      'Genererer synsk besked'
                    )
                  )
                )
              )
            )
          ),
          React.createElement(Waveform, { active: audioPlaying }),
          (stage !== 'START' && stage !== 'GOODBYE') && React.createElement('div', { className: 'controls' },
            (stage === 'MEMORY_1' || stage === 'MEMORY_2' || stage === 'QUESTION_1' || stage === 'QUESTION_2') && React.createElement('button', {
              className: 'control-btn' + (isListening ? ' active' : ''),
              onClick: startVoice,
              type: 'button'
            }, isListening 
              ? (language === 'en' ? '◉ LISTENING' : '◉ LYTTER')
              : (language === 'en' ? '🎤 TALK' : '🎤 TAL')
            ),
            React.createElement('button', {
              className: 'control-btn' + (audioPlaying ? ' active' : ''),
              onClick: togglePlayPause,
              disabled: !audioReady
            }, audioPlaying 
              ? '⏸ PAUSE'
              : (language === 'en' ? '▶ PLAY' : '▶ AFSPIL')
            ),
            React.createElement('button', {
              className: 'control-btn',
              onClick: skipAudio,
              disabled: audioQueue.length === 0 && !audioPlaying
            }, language === 'en' ? '⏭ SKIP' : '⏭ SPRING OVER')
          ),
          React.createElement('form', { className: 'input-area', onSubmit: send },
            (stage !== 'START' && stage !== 'WELCOME' && stage !== 'GOODBYE') && React.createElement('input', {
              value: input,
              onChange: e => setInput(e.target.value),
              placeholder: getPlaceholder(),
              disabled: loading
            }),
            React.createElement('button', {
              className: 'control-btn start-btn',
              type: 'submit',
              disabled: loading || (stage !== 'START' && stage !== 'WELCOME' && stage !== 'GOODBYE' && !input.trim())
            }, loading ? '...' : getButtonText())
          ),
          React.createElement('audio', { id: 'bot-audio', ref: audioEl, hidden: true })
        );
      }

      ReactDOM.createRoot(document.getElementById('root')).render(React.createElement(App));
    </script>
  </body>
</html>
